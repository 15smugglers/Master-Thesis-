#Worksheet 3
#1 Basic apply and simliar
#a)
out=replicate(50,rt(10,5),simplify = FALSE)
class(out)
out
#b)
?mapply
rt(10,1:10)
rt(10,1)
rt(10,1)
#b)
c=mapply(seq,from=c(1,4,-3),to=c(2,9,0),by=0.5)
class(c)
#b)
c=mapply(seq,from=c(1,4,-3),to=c(2,9,0),by=0.5,SIMPLIFY = array)
class(c)
#b)
c=mapply(seq,from=c(1,4,-3),to=c(2,9,0),by=0.5,simplify = array)
class(c)
#b)
?mapply
maplly(rep(1:4,4:1))
mapply(rep(1:4,4:1))
mapply(rep(1:4,4:1))
mapply(rep,1:4,4:1)
mapply(rep,1:4,4:1,SIMPLIFY = TRUE)
c=mapply(rep,1:4,4:1,SIMPLIFY = TRUE)
class(c)
mapply(rep,1:4,4:1)
sapply(rep,1:4,4:1)
mapply(function(x, y) seq_len(x) + y,
c(a =  1, b = 2, c = 3),  # names from first
c(A = 10, B = 0, C = -10))
word <- function(C, k) paste(rep.int(C, k), collapse = "")
#c)
?lapply
a=1:20
a
a=list(x=1:20)
a
a=list(x=1:20)
lapply(a,function(x){
x=x[1:x]
return(x)
})
x
a <- list(
x = runif(10),
y = runif(23)
)
result1 <- lapply(a, function(x) { y <- sort(x)
z <- y[y > 0.5]
return(mean(z)) })
a
z
x
a=list(x=1:20)
lapply(a,function(x){
x=x[1:x]
return(x)
})
x
a
class(x)
x <- list(a = 1:10, beta = exp(-3:3), logic = c(TRUE,FALSE,FALSE,TRUE))
# compute the list mean for each list element
lapply(x, mean)
a=list(x=1:20)
lapply(a,function(x){
x=x[1:x]
return(x)
})
#HOW?
length(x)
x
?lapply
a=list(x=1:20)
lapply(a,function(x){
x=x[1:x]
return(x)
})
#HOW?
x
x
a=list(x=1:20)
a
a=list(x=1:20)
lapply(a,function(x){
a=a[1:x]
return(a)
})
#HOW?
a
length(a)
a=list(x=1:20)
length(a)
for(i in 1:4) a=list(x[i]=1:i)
a
for(i in 1:4) a=list(x[i]=1:i)
for(i in 1:4) a=list(x=1:i)
a
for(i in 1:4) a=list()
a=list()
for(i in 1:3) a[[i]]=1:i
a
lapply(a,for(i in 1:20) a[[i]]=1:i)
lapply(a,function(i) a[[i]]=1:i)
a
a=list()
lapply(a,function(i) a[[i]]=1:i)
a
a=list()
i=20
lapply(a,function(i) a[[i]]=1:i)
a
i=1:20
lapply(a,function(i) a[[i]]=1:i)
a
a=list()
i=1:20
lapply(a,function(i) a[[i]]=1:i)
a
#c)
# Generate a list where the i-th entry is the sequence of numbers 1,...,i
result <- lapply(1:20, function(i) seq(1, i))
# Print the result to check the output
print(result)
class(result)
class(1:10)
?lapply
result2=lapply(1:20,function(i)i^2)
result2
class(result2)
result2=lapply(1:20,k=sort(k))
result2=lapply(1:20,function(k)k=sort(k))
result2
result3=lapply(1:10,i^2)
result3=lapply(1:10,function(i)i^2)
result3
library(tidyverse)
install.packages("tidyverse")
install.packages("tidyverse")
install.packages("tidyverse")
library(tidyverse)
install.packages("tidyverse")
install.packages("tidyverse")
library(tidyverse)
library(tidyverse)
library(tidyverse)
?gather
?spread
spread
spread()
install.packages("tidyverse")
install.packages("tidyverse")
spread()
library(tidyverse)
install.packages(tidyverse)
install.packages("tidyverse")
install.packages("tidyverse")
install.packages("tidyverse")
library(tidyverse)
install.packages("tzdb")
install.packages("knitr")
install.packages("tidyverse")
24*30
720/96
9+9+8+6+4+4+3+22+2+6+5+3+10+5
42/6
(42/6)*(12/96)
(42/6)*(96/12)
10.5*6/42
10.5/(42/96)
4/(16/96)
6*42/96 *24
6*42/96 /24
6/24
10.5*96 /42 /6
6/4 *(42/96)
(10.5 /6)*(96/42)
24*(42/96)
6712
6&12
6/12
(6/96)*(42/96)/(12/96)
96*0.21875
10.5/(6*42/96)
6*4
24*(42/96)
24*(16/96)
(6*41)/(96*96)
cumsum(c(1,2,3))
log(-2)
log(0)
ln(-2)
pnorm(0)
log(9)
log(0)
log(1)
library(ape)
install.packages("ape")
#install.packages("ape")
library(ape)
rt = rcoal(10)
plot.phylo(rt)
rt = rcoal(10)
plot.phylo(rt)
log(0)
log(999999999999)
print("Hallo")
print("Hallo")
version()
version()
install.packages("igraph")
BiocManager::install(c("RBGL","graph"))  # einmalig
library(igraph)
library(graph)
library(RBGL)
# === Eingabe: Kantenliste (parallele Kanten einfach mehrfach eintragen) ===
edges <- data.frame(
from = c(1,2,3, 1, 1, 2),
to   = c(2,3,1, 2, 3, 1)
)
# Das entspricht: 1->2, 2->3, 3->1, 1->2 (zweites Mal), 1->3, 2->1
# (Dein 2-Zyklus ist 1->2->1; "1->2->2" war vermutlich ein Vertipper.)
# === (A) Multigraph in igraph (f체r Multiplikit채ten) ===
g_multi <- graph_from_data_frame(edges, directed = TRUE)
edge_mult <- function(u, v) {
uu <- V(g_multi)[name == as.character(u)]
vv <- V(g_multi)[name == as.character(v)]
length(E(g_multi)[ from(uu) & to(vv) ])
}
# === (B) "Einfache" gerichtete Struktur f체r Johnson (ohne Parallelkanten) ===
edges_unique <- unique(edges)  # Kantenart nur einmal
nodes <- sort(unique(c(edges_unique$from, edges_unique$to)))
gNEL <- graphNEL(nodes = as.character(nodes), edgemode = "directed")
for (i in seq_len(nrow(edges_unique))) {
gNEL <- addEdge(as.character(edges_unique$from[i]),
as.character(edges_unique$to[i]),
gNEL)
}
# === (C) Alle elementaren Zyklen 체ber Knoten (Johnson) ===
cyc <- johnson.all.cycles(gNEL)  # Liste von Vektoren, z.B. c("1","2","3")
exp(-4.869927)
v <- rep(1,10)
vt <- t(v)
vt
v
v*vt
v%*%vt
1/10*v%*%vt
diag(10)-1/10*v%*%vt
v <- rep(1,2)
vt <- t(v)
1/2*v%*%vt
diag(2)-1/2*v%*%vt
diag(3)-1/2*v%*%vt
v <- rep(1,3)
vt <- t(v)
1/3*v%*%vt
diag(3)-1/2*v%*%vt
v <- rep(1,4)
vt <- t(v)
1/4*v%*%vt
diag(4)-1/2*v%*%vt
v <- rep(1,4)
vt <- t(v)
1/4*v%*%vt
diag(4)-1/4*v%*%vt
v <- rep(1,100)
vt <- t(v)
1/100*v%*%vt
diag(100)-1/100*v%*%vt
qm <- diag(100)-1/100*v%*%vt
qm
v <- rep(1,m)
m <- 100
v <- rep(1,m)
vt <- t(v)
1/m*v%*%vt
qm <- diag(m)-1/m*v%*%vt
qm
qm
qm%*%seq(1:m)
sum(qm%*%seq(1:m))
v <- c(1,2,3,1)
sum(diff(v)<=0
v <- c(1,2,3,1)
v <- c(1,2,3,1)
v
sum(diff(v)<=0)
nd <- length(v)
sum(diff(v)<=0) <(nd-1)
v <- v - mean(v)
nd <- length(v)
sum(diff(v)<=0) <(nd-1)
v
?dvnorm(
)
dmvnorm(x=c(0,0))
library(mvtnorm)
dmvnorm(x=c(0,0))
dmvnorm(x=c(0,0), mean=c(1,1))
100*65
100*65-(55*8+62*6+62*6+7:5*62+7.5*64+67*7.5+64*7.5+74*25)
100*65-(55*8+62*6+62*6+7.5*62+7.5*64+67*7.5+64*7.5+74*25)
100*65-(55*8+62*6+62*6+7.5*62+7.5*64+67*7.5+64*7.5+74*25)/25
(100*65-(55*8+62*6+62*6+7.5*62+7.5*64+67*7.5+64*7.5+74*25))/25
(100*65-(65*8+62*6+62*6+7.5*62+7.5*64+67*7.5+64*7.5+74*25))/25
(100*65-(55*8+62*6+62*6+7.5*62+7.5*64+67*7.5+64*7.5+74*25))/25
(100*65-(75*8+62*6+62*6+7.5*62+7.5*64+67*7.5+64*7.5+74*25))/25
(100*65-(55*8+62*6+62*6+7.5*62+7.5*64+67*7.5+64*7.5+74*25))/25
(100*65-(55*8+62*6+67*6+7.5*62+7.5*64+67*7.5+64*7.5+74*25))/25
(100*65-(55*8+62*6+62*6+7.5*62+7.5*64+67*7.5+64*7.5+77*25))/25
(55*8+62*6+62*6+7.5*62+7.5*64+67*7.5+64*7.5+74*25)
(55*8+62*6+62*6+7.5*62+7.5*64+67*7.5+64*7.5+74*25)/75
load("~/Library/Mobile Documents/com~apple~CloudDocs/Studium/Dissertation MSc/Data/Finals_Runs/Modified/example-FT-a-dir/example-FT.RData")
X
betamcmc
elpd <- function(filename, burnin=1, subsample=1, num.years=T){
load(filename)
#this shouldnt be needed - if it is we need to know
if(note$DOSYNTH){if(!identical(cla,scla)) stop('wierdness encountered in elpd')}
#drop 1:(burnin-1) and allow subsampling for large output
P  <- P[seq(burnin, nrow(P), subsample), ]
PO <- PO[seq(burnin, nrow(P), subsample)]
i.na <- !is.na(P[,1])
P  <- P[i.na, ]
PO <- PO[i.na]
tau.ind <- grep("tau", colnames(P))
#compute log.lkd's
l.list <- matrix(NA, nrow(P), length(cla))
for(i in 1:nrow(l.list)){
l.list[i, ] <- unlist(
log.lkd.ser(
PO[[i]], cla, year2list(P[i, tau.ind], num.years),
years = 1:num.years,
p     = P[i, "p"],        # <-- hier der Fix (vorher P[i, 9])
model = note$model
)
)
}
ess <- effectiveSize(l.list)
loo_result  <- loo::loo(x = l.list, r_eff = ess)
waic_result <- loo::waic(l.list)
PO_bar <- PO[[1]]
for(i in 1:length(PO_bar)){ PO_bar[[i]] <- PO_bar[[i]] - PO_bar[[i]] }
for (i1 in 1:length(PO)){
for(i2 in 1:length(PO_bar)){
PO_bar[[i2]] <- PO_bar[[i2]] + PO[[i1]][[i2]]
}
}
for(i in 1:length(PO_bar)){ PO_bar[[i]] <- ((PO_bar[[i]]/i1) >= 0.5) + 0 }
l.bar <- sum(unlist(log.lkd.ser(PO_bar, cla, state$y2l, years=1:T,
p=mean(P[, "p"]), model=note$model)))
DIC <- 2*l.bar - 4*mean(P[,1])
return(list(loo_result=loo_result, waic_result=waic_result, DIC=DIC))
}
elpd <- function(filename, burnin=1, subsample=1, num.years=T){
load(filename)
#this shouldnt be needed - if it is we need to know
if(note$DOSYNTH){if(!identical(cla,scla)) stop('wierdness encountered in elpd')}
#drop 1:(burnin-1) and allow subsampling for large output
P  <- P[seq(burnin, nrow(P), subsample), ]
PO <- PO[seq(burnin, nrow(P), subsample)]
i.na <- !is.na(P[,1])
P  <- P[i.na, ]
PO <- PO[i.na]
tau.ind <- grep("tau", colnames(P))
#compute log.lkd's
l.list <- matrix(NA, nrow(P), length(cla))
for(i in 1:nrow(l.list)){
l.list[i, ] <- unlist(
log.lkd.ser(
PO[[i]], cla, year2list(P[i, tau.ind], num.years),
years = 1:num.years,
p     = P[i, "p"],        # <-- hier der Fix (vorher P[i, 9])
model = note$model
)
)
}
ess <- effectiveSize(l.list)
loo_result  <- loo::loo(x = l.list, r_eff = ess)
waic_result <- loo::waic(l.list)
PO_bar <- PO[[1]]
for(i in 1:length(PO_bar)){ PO_bar[[i]] <- PO_bar[[i]] - PO_bar[[i]] }
for (i1 in 1:length(PO)){
for(i2 in 1:length(PO_bar)){
PO_bar[[i2]] <- PO_bar[[i2]] + PO[[i1]][[i2]]
}
}
for(i in 1:length(PO_bar)){ PO_bar[[i]] <- ((PO_bar[[i]]/i1) >= 0.5) + 0 }
l.bar <- sum(unlist(log.lkd.ser(PO_bar, cla, state$y2l, years=1:T,
p=mean(P[, "p"]), model=note$model)))
DIC <- 2*l.bar - 4*mean(P[,1])
return(list(loo_result=loo_result, waic_result=waic_result, DIC=DIC))
}
path <- c("/Users/finnmaass/Downloads/Results_Thesis/PO/5 Year Block/Female/BUC/1970_1974/example-FT-a-dir/example-FT.RData"
)
elpd(path)
elpd <- function(filename, burnin=1, subsample=1, num.years=T){
load(filename)
#this shouldnt be needed - if it is we need to know
if(note$DOSYNTH){if(!identical(cla,scla)) stop('wierdness encountered in elpd')}
#drop 1:(burnin-1) and allow subsampling for large output
P  <- P[seq(burnin, nrow(P), subsample), ]
PO <- PO[seq(burnin, nrow(P), subsample)]
i.na <- !is.na(P[,1])
P  <- P[i.na, ]
PO <- PO[i.na]
tau.ind <- grep("tau", colnames(P))
#compute log.lkd's
l.list <- matrix(NA, nrow(P), length(cla))
for(i in 1:nrow(l.list)){
l.list[i, ] <- unlist(
log.lkd.ser(
PO[[i]], cla, year2list(P[i, tau.ind], num.years),
years = 1:num.years,
p     = P[i, "p"],        # <-- hier der Fix (vorher P[i, 9])
model = note$model
)
)
}
ess <- effectiveSize(l.list)
loo_result  <- loo::loo(x = l.list, r_eff = ess)
waic_result <- loo::waic(l.list)
PO_bar <- PO[[1]]
for(i in 1:length(PO_bar)){ PO_bar[[i]] <- PO_bar[[i]] - PO_bar[[i]] }
for (i1 in 1:length(PO)){
for(i2 in 1:length(PO_bar)){
PO_bar[[i2]] <- PO_bar[[i2]] + PO[[i1]][[i2]]
}
}
for(i in 1:length(PO_bar)){ PO_bar[[i]] <- ((PO_bar[[i]]/i1) >= 0.5) + 0 }
l.bar <- sum(unlist(log.lkd.ser(PO_bar, cla, state$y2l, years=1:T,
p=mean(P[, "p"]), model=note$model)))
DIC <- 2*l.bar - 4*mean(P[,1])
return(list(loo_result=loo_result, waic_result=waic_result, DIC=DIC))
}
path <- c("/Users/finnmaass/Downloads/Results_Thesis/PO/5 Year Block/Female/BUC/1970_1974/example-FT-a-dir/example-FT.RData"
)
elpd(path)
load("~/Downloads/Results_Thesis/PL/5 Year Block/Female/BUC/1970_1974/example-FT-a-dir/example-FT.RData")
############### log lik function ###
logpp <- function(dp,lambda,beta,B){
##the log lik contribution of a single list
o <- dp$o
n <- length(o)
t <- dp$time
r <- dp$rank
f <- lambda[o,t-B+1] +beta[r]
ff <- numeric(n)
for(j in 1:n){
ff[j]<- f[j]- log(sum(exp(f[j:n]))) #likelihood for one chimp
}
return(sum(ff))
}
PL_log_lik <- function(D,lambda,beta,B){
logp <- sapply(D,function(x) logpp(dp=x,lambda=lambda,beta=beta,B=B))
return(sum(logp)) #take the sum b.c. we look at the log likelihood!
}
################## check for convergence
###### log lik
l <- numeric(M/SS)
for(i in 1:(M/SS)){
l[i]<- PL_log_lik(D=D,lambda=lambdamcmc[,,i],beta=betamcmc[,i],B=B)
}
plot(l,type='l')
plot(l[-(1:1000)],type='l',ylab="log-lik")
#######sigma
plot(sigmamcmc,type='l')
############beta
plot(betamcmc[1,-c(1:1000)],type='l',ylim=c(-3,3)) #5 b.c. we just pick a random one?
########## checking the monotonicity of the betas
C <- matrix(0,(M/SS)*nd,2)
for(i in 1:nd){
C[((i-1)*(M/SS)+1):(i*(M/SS)),1]<- betamcmc[i,]
C[((i-1)*(M/SS)+1):(i*(M/SS)),2]<- i
}
boxplot(C[,1]~C[,2],ylab="values",xlab="ranks")
abline(h=0,col='red',lty="dashed")
load("~/Downloads/Results_Thesis/PO/Entire Data/Female/BUC/example-FT-b-dir/example-FT.RData")
note$DOTAU
cla
cla[[591]]
cla[[590]]
setwd("~/Downloads/Results_Thesis/PL/Entire Data/Male/BUC")
setwd("~/Downloads/Results_Thesis/PL/Entire Data/Male/BUC")
load("~/Downloads/Results_Thesis/PL/Entire Data/Male/BUC/example-FT-b-dir/example-FT.RData")
plot(lambdamcmc[10,10,-c(1:1000)],type='l',ylab = expression(lambda))
save_last_plot_pdf("m_lambda_traceplot")
#Setup do run and store pictures as pdf
library(dplyr)
index <- first(which(sigmamcmc==0))-1
## Get M
M=SS*index
## Chop down data
lambdamcmc <-lambdamcmc[,,1:index]
betamcmc <- betamcmc[,1:index]
sigmamcmc <- sigmamcmc[1:index]
thetamcmc <- thetamcmc[1:index]
PLOTDIR <- getwd()
save_last_plot_pdf <- function(name,
dir = PLOTDIR,
width_in = 7, height_in = 5) {
pdf_file <- file.path(dir, paste0(name, ".pdf"))
grDevices::dev.copy2pdf(file = pdf_file, width = width_in, height = height_in)
message("Gespeichert: ", pdf_file)
}
plot(lambdamcmc[10,10,-c(1:1000)],type='l',ylab = expression(lambda))
save_last_plot_pdf("m_lambda_traceplot")
