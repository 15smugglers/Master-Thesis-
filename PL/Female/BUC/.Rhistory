Lambda_beta=rep(0,n))
for(i in 1:n){
df_winner$Chimp[i] <- test[[i]]$o[1]
df_winner$Rank[i] <- test[[i]]$rank[1]
chimp <- test[[i]]$o[1]; rank <- test[[i]]$rank[1]
df_winner$Lambda_beta[i] <- lambda[chimp]+beta[rank]
}
df_loser <- data.frame(Chimp=rep(0,n),
Rank=rep(0,n),
Lambda_beta=rep(0,n))
for(i in 1:n){
df_loser$Chimp[i] <- test[[i]]$o[2]
df_loser$Rank[i] <- test[[i]]$rank[2]
chimp <- test[[i]]$o[2]; rank <- test[[i]]$rank[2]
df_loser$Lambda_beta[i] <- lambda[chimp]+beta[rank]
}
df <- rbind(df_winner,df_loser)
## now we can read the ranking from here!
df %>% arrange(desc(Lambda_beta))
test <- Filter(function(x) all(x$time>=1988 && x$time <=1991), D)
unique(unlist(sapply(test,function(x) x$o)))
test
n <- length(test)
df_winner <- data.frame(Chimp=rep(0,n),
Rank=rep(0,n),
Lambda_beta=rep(0,n))
for(i in 1:n){
df_winner$Chimp[i] <- test[[i]]$o[1]
df_winner$Rank[i] <- test[[i]]$rank[1]
chimp <- test[[i]]$o[1]; rank <- test[[i]]$rank[1]
df_winner$Lambda_beta[i] <- lambda[chimp]+beta[rank]
}
df_loser <- data.frame(Chimp=rep(0,n),
Rank=rep(0,n),
Lambda_beta=rep(0,n))
for(i in 1:n){
df_loser$Chimp[i] <- test[[i]]$o[2]
df_loser$Rank[i] <- test[[i]]$rank[2]
chimp <- test[[i]]$o[2]; rank <- test[[i]]$rank[2]
df_loser$Lambda_beta[i] <- lambda[chimp]+beta[rank]
}
df <- rbind(df_winner,df_loser)
## now we can read the ranking from here!
df %>% arrange(desc(Lambda_beta))
test <- Filter(function(x) all(x$time>=1985 && x$time <=1991), D)
unique(unlist(sapply(test,function(x) x$o)))
test
n <- length(test)
df_winner <- data.frame(Chimp=rep(0,n),
Rank=rep(0,n),
Lambda_beta=rep(0,n))
for(i in 1:n){
df_winner$Chimp[i] <- test[[i]]$o[1]
df_winner$Rank[i] <- test[[i]]$rank[1]
chimp <- test[[i]]$o[1]; rank <- test[[i]]$rank[1]
df_winner$Lambda_beta[i] <- lambda[chimp]+beta[rank]
}
df_loser <- data.frame(Chimp=rep(0,n),
Rank=rep(0,n),
Lambda_beta=rep(0,n))
for(i in 1:n){
df_loser$Chimp[i] <- test[[i]]$o[2]
df_loser$Rank[i] <- test[[i]]$rank[2]
chimp <- test[[i]]$o[2]; rank <- test[[i]]$rank[2]
df_loser$Lambda_beta[i] <- lambda[chimp]+beta[rank]
}
df <- rbind(df_winner,df_loser)
## now we can read the ranking from here!
df %>% arrange(desc(Lambda_beta))
test <- Filter(function(x) all(x$time>=1985 && x$time <=1992), D)
unique(unlist(sapply(test,function(x) x$o)))
test
n <- length(test)
df_winner <- data.frame(Chimp=rep(0,n),
Rank=rep(0,n),
Lambda_beta=rep(0,n))
for(i in 1:n){
df_winner$Chimp[i] <- test[[i]]$o[1]
df_winner$Rank[i] <- test[[i]]$rank[1]
chimp <- test[[i]]$o[1]; rank <- test[[i]]$rank[1]
df_winner$Lambda_beta[i] <- lambda[chimp]+beta[rank]
}
df_loser <- data.frame(Chimp=rep(0,n),
Rank=rep(0,n),
Lambda_beta=rep(0,n))
for(i in 1:n){
df_loser$Chimp[i] <- test[[i]]$o[2]
df_loser$Rank[i] <- test[[i]]$rank[2]
chimp <- test[[i]]$o[2]; rank <- test[[i]]$rank[2]
df_loser$Lambda_beta[i] <- lambda[chimp]+beta[rank]
}
df <- rbind(df_winner,df_loser)
## now we can read the ranking from here!
df %>% arrange(desc(Lambda_beta))
D[[592]]
D[[591]]
test <- Filter(function(x) all(x$time>=1985 && x$time <= 1992), D)
unique(unlist(sapply(test,function(x) x$o)))
test
n <- length(test)
df_winner <- data.frame(Chimp=rep(0,n),
Rank=rep(0,n),
Lambda_beta=rep(0,n))
for(i in 1:n){
df_winner$Chimp[i] <- test[[i]]$o[1]
df_winner$Rank[i] <- test[[i]]$rank[1]
chimp <- test[[i]]$o[1]; rank <- test[[i]]$rank[1]
df_winner$Lambda_beta[i] <- lambda[chimp]+beta[rank]
}
df_loser <- data.frame(Chimp=rep(0,n),
Rank=rep(0,n),
Lambda_beta=rep(0,n))
for(i in 1:n){
df_loser$Chimp[i] <- test[[i]]$o[2]
df_loser$Rank[i] <- test[[i]]$rank[2]
chimp <- test[[i]]$o[2]; rank <- test[[i]]$rank[2]
df_loser$Lambda_beta[i] <- lambda[chimp]+beta[rank]
}
df <- rbind(df_winner,df_loser)
## now we can read the ranking from here!
df %>% arrange(desc(Lambda_beta))
## now we can read the ranking from here!
df %>% arrange(desc(Lambda_beta))
test
n
df
df$Chimp==28
sum(df$Chimp==28)
## now we can read the ranking from here!
df %>% arrange(desc(Lambda_beta))
test <- Filter(function(x) all(x$time>=1990 && x$time <= 1991), D)
unique(unlist(sapply(test,function(x) x$o)))
test
n <- length(test)
df_winner <- data.frame(Chimp=rep(0,n),
Rank=rep(0,n),
Lambda_beta=rep(0,n))
for(i in 1:n){
df_winner$Chimp[i] <- test[[i]]$o[1]
df_winner$Rank[i] <- test[[i]]$rank[1]
chimp <- test[[i]]$o[1]; rank <- test[[i]]$rank[1]
df_winner$Lambda_beta[i] <- lambda[chimp]+beta[rank]
}
df_loser <- data.frame(Chimp=rep(0,n),
Rank=rep(0,n),
Lambda_beta=rep(0,n))
for(i in 1:n){
df_loser$Chimp[i] <- test[[i]]$o[2]
df_loser$Rank[i] <- test[[i]]$rank[2]
chimp <- test[[i]]$o[2]; rank <- test[[i]]$rank[2]
df_loser$Lambda_beta[i] <- lambda[chimp]+beta[rank]
}
df <- rbind(df_winner,df_loser)
## now we can read the ranking from here!
df %>% arrange(desc(Lambda_beta))
D_sub <- Filter(function(x) all(x$time>=1990 && x$time <= 1991), D)
unique(unlist(sapply(D_sub,function(x) x$o)))
n <- length(D_sub)
df_winner <- data.frame(Chimp=rep(0,n),
Rank=rep(0,n),
Lambda_beta=rep(0,n))
for(i in 1:n){
df_winner$Chimp[i] <- D_sub[[i]]$o[1]
df_winner$Rank[i] <- D_sub[[i]]$rank[1]
chimp <- D_sub[[i]]$o[1]; rank <- D_sub[[i]]$rank[1]
df_winner$Lambda_beta[i] <- lambda[chimp]+beta[rank]
}
df_loser <- data.frame(Chimp=rep(0,n),
Rank=rep(0,n),
Lambda_beta=rep(0,n))
for(i in 1:n){
df_loser$Chimp[i] <- D_sub[[i]]$o[2]
df_loser$Rank[i] <- D_sub[[i]]$rank[2]
chimp <- D_sub[[i]]$o[2]; rank <- D_sub[[i]]$rank[2]
df_loser$Lambda_beta[i] <- lambda[chimp]+beta[rank]
}
df <- rbind(df_winner,df_loser)
df
## now we can read the ranking from here!
## Note that chiimp 28 enters in 1992! Therefore, we put it on last rank (highest seniority rank)
## Chimp 22 does not interact in that time
##
df %>% arrange(desc(Lambda_beta))
## males ##
# Fitting model 1
res_m_model1 <- optim(par=5, burn_in=100, elo.model1, all_ids = all_males, IA_data = male_ago, return_likelihood=T, method='Brent', lower=-10, upper=10)
#### Code from Paper ####
################################################################################
# Model 1 -- constant initial socres + fitting k
################################################################################
elo.model1 <- function(par, burn_in=100, init_elo = 1000, IA_data, all_ids, return_likelihood = T)
{
k <- par
# Initialize output columns
if (!return_likelihood) IA_data$elo_l_before <- IA_data$elo_w_before <- IA_data$elo_l_after <- IA_data$elo_w_after <- NA
# Set intitial elo scores
currentELO <- rep(init_elo,length(all_ids))
names(currentELO) <- all_ids
# Initialize the log likelihood
L <- 0
# Start loop
for(i in 1:nrow(IA_data))
{
ind1 <- which(names(currentELO)==IA_data$Winner[i]) #gives the indices of the winners
ind2 <- which(names(currentELO)==IA_data$Loser[i]) #gives the indices of the losers
if (!return_likelihood) #nur ausgefÃ¼hrt wenn return_likelihood wrong wegen
{
IA_data$elo_w_before[i] <- currentELO[ind1] #elo scores winners
IA_data$elo_l_before[i] <- currentELO[ind2] #elo scores losers
}
# calculate predited winning probablity of the winner
p_win <- 1/(1+exp(-.01*(currentELO[ind1] - currentELO[ind2])))
# Calculation of new ELO scores
if (i <= burn_in) # during burn-in period all k values are fixed to 100
{
currentELO[ind1] <- currentELO[ind1] + 100 * (1 - p_win) # new Elo score of the Winner
currentELO[ind2] <- currentELO[ind2] - 100 * (1 - p_win) # new Elo score of the Loser
}
else # after the burn-in period fitted k values are used
{
currentELO[ind1] <- currentELO[ind1] + exp(k) * (1 - p_win) # new Elo score of the Winner
currentELO[ind2] <- currentELO[ind2] - exp(k) * (1 - p_win) # new Elo score of the Loser
}
# write calculated elo scores to output columns
if (!return_likelihood)
{
IA_data$elo_w_after[i] <- currentELO[ind1]
IA_data$elo_l_after[i] <- currentELO[ind2]
}
# Update log likelihood
if (i > burn_in) L <- L + log(p_win)
}
if (return_likelihood) return(-1*L)
else return(IA_data)
}
################################################################################
# Model 2 -- initial scores at hierarchy bottom + fitting k
################################################################################
elo.model2 <- function(par, burn_in=100, init_elo = 0, IA_data, pres_data, all_ids, return_likelihood = T)
{
k <- par
# Initialize output columns
if (!return_likelihood) IA_data$elo_l_before <- IA_data$elo_w_before <- IA_data$elo_l_after <- IA_data$elo_w_after <- NA
# Set intitial elo scores
currentELO <- rep(init_elo,length(all_ids))
names(currentELO) <- all_ids
# Initialize the log likelihood
L <- 0
# Start loop
for(i in 1:nrow(IA_data))
{
ind1 <- which(names(currentELO)==IA_data$Winner[i])
ind2 <- which(names(currentELO)==IA_data$Loser[i])
if (!return_likelihood)
{
IA_data$elo_w_before[i] <- currentELO[ind1]
IA_data$elo_l_before[i] <- currentELO[ind2]
}
# calculate predited winning probablity of the winner
p_win <- 1/(1+exp(-.01*(currentELO[ind1] - currentELO[ind2])))
# Calculation of new ELO scores
if (i <= burn_in) # during burn-in period all k values are fixed to 100
{
currentELO[ind1] <- currentELO[ind1] + 100 * (1 - p_win) # new Elo score of the Winner
currentELO[ind2] <- currentELO[ind2] - 100 * (1 - p_win) # new Elo score of the Loser
}
else # after the burn-in period fitted k values are used
{
currentELO[ind1] <- currentELO[ind1] + exp(k) * (1 - p_win) # new Elo score of the Winner
currentELO[ind2] <- currentELO[ind2] - exp(k) * (1 - p_win) # new Elo score of the Loser
}
#rescale Elo scores of present individuals so that the smallest Elo score is 0
presence <- pres_data[pres_data$Date == IA_data$Date[i], 2:ncol(pres_data)]==1
currentELO[presence] <- currentELO[presence] - min(currentELO[presence])
# write calculated elo scores to output columns
if (!return_likelihood)
{
IA_data$elo_w_after[i] <- currentELO[ind1]
IA_data$elo_l_after[i] <- currentELO[ind2]
}
# Update log likelihood
if (i > burn_in) L <- L + log(p_win)
}
if (return_likelihood) return(-1*L)
else return(IA_data)
}
################################################################################
# Model 3 -- fitting of initial scores and k
################################################################################
elo.model3 <- function(par, IA_data, all_ids, return_likelihood = T)
{
k <- par[1]
init_elo <- par[2:length(par)]
# Initialize output columns
if (!return_likelihood) IA_data$elo_l_before <- IA_data$elo_w_before <- IA_data$elo_l_after <- IA_data$elo_w_after <- NA
# Set intitial elo scores
currentELO <- c(init_elo)
names(currentELO) <- all_ids
# Initialize the log likelihood
L <- 0
# Start loop
for(i in 1:nrow(IA_data))
{
ind1 <- which(names(currentELO)==IA_data$Winner[i])
ind2 <- which(names(currentELO)==IA_data$Loser[i])
if (!return_likelihood)
{
IA_data$elo_w_before[i] <- currentELO[ind1]
IA_data$elo_l_before[i] <- currentELO[ind2]
}
# calculate predited winning probablity of the winner
p_win <- 1/(1+exp(-.01*(currentELO[ind1] - currentELO[ind2])))
# Calculation of new ELO scores
currentELO[ind1] <- currentELO[ind1] + exp(k) * (1 - p_win) # new Elo score of the Winner
currentELO[ind2] <- currentELO[ind2] - exp(k) * (1 - p_win) # new Elo score of the Loser
# write calculated elo scores to output columns
if (!return_likelihood)
{
IA_data$elo_w_after[i] <- currentELO[ind1]
IA_data$elo_l_after[i] <- currentELO[ind2]
}
# Update log likelihood
L <- L + log(p_win)
}
if (return_likelihood) return(-1*L)
else return(IA_data)
}
################################################################################
# Read data
################################################################################
# females
female_ago <- read.csv2(file.choose(), header = T)
female_ago$Winner <- as.character(female_ago$Winner)
female_ago$Loser <- as.character(female_ago$Loser)
female_ago$Date <- as.character(female_ago$Date)
female_presence <- read.csv2(file.choose(), header=T, check.names=F, stringsAsFactors=F, sep=";")
female_presence$Date <- as.character(female_presence$Date)
## vector with female IDs
all_females <- c(1:44)
# males
male_ago <- read.csv2(file.choose(), header=T, stringsAsFactors=F, sep=";")
male_ago$Winner <- as.character(male_ago$Winner)
male_ago$Loser <- as.character(male_ago$Loser)
male_ago$Date <- as.character(male_ago$Date)
male_presence <- read.csv2(file.choose(), header=T, check.names=F, stringsAsFactors=F, sep=";")
male_presence <- male_presence[, -1]
male_presence$Date <- as.character(male_presence$Date)
## vector with male IDs
all_males <- c(1:22)
# table with results of model fitting
results_f <- data.frame('model' = 1:3, 'convergence' = NA, 'AIC' = NA, 'delta_AIC' = NA, 'k' = NA, 'pred_accuracy'=NA)
results_m <- data.frame('model' = 1:3, 'convergence' = NA, 'AIC' = NA, 'delta_AIC' = NA, 'k' = NA, 'pred_accuracy'=NA)
## males ##
# Fitting model 1
res_m_model1 <- optim(par=5, burn_in=100, elo.model1, all_ids = all_males, IA_data = male_ago, return_likelihood=T, method='Brent', lower=-10, upper=10)
k_m <- (res_m_model1$par)
male_elos <- elo.model1(par=k_m,burn_in=100, init_elo = 1000,IA_data = male_ago,all_ids=all_males,return_likelihood = F)
male_elos$Date <- as.Date(male_elos$Date, format = "%d.%m.%Y")
sort_rankings(male_elos)
sort_rankings <- function(elo_score){
elo_score%>%
tidyr::pivot_longer(
cols = c(Winner, Loser),
names_to = "Role",
values_to = "Chimp"
) %>%
mutate(Elo_after = ifelse(Role == "Winner", elo_w_after, elo_l_after)) %>%
group_by(Chimp) %>%
summarise(mean_elo = mean(Elo_after, na.rm = TRUE)) %>%
arrange(desc(mean_elo))
}
sort_rankings(male_elos)
male_elos_2yr <- male_elos %>% filter(Date > "1989-01-01" & Date <"1989-12-31") %>% arrange(desc(elo_w_after)) %>% arrange(desc(elo_l_after))
sort_rankings(male_elos_2yr)
load("/Users/finnmaass/Downloads/Results_Thesis/PL/Entire Data/Male/BUC/example-FT-b-dir/example-FT.RData")
lambdamcmc
lambdamcmc[,,1]
### Load the data for the males into the global environment
lambda <- lambdamcmc[,10,1:5000]
lambda <- apply(lambda,1,mean,na.rm=TRUE)
beta <- betamcmc[,1:5000]
beta <- apply(beta,1,function(x) mean(x[x != 0], na.rm = TRUE))
D_sub <- Filter(function(x) all(x$time>=1989 && x$time <= 1989), D)
unique(unlist(sapply(D_sub,function(x) x$o)))
n <- length(D_sub)
df_winner <- data.frame(Chimp=rep(0,n),
Rank=rep(0,n),
Lambda_beta=rep(0,n))
for(i in 1:n){
df_winner$Chimp[i] <- D_sub[[i]]$o[1]
df_winner$Rank[i] <- D_sub[[i]]$rank[1]
chimp <- D_sub[[i]]$o[1]; rank <- D_sub[[i]]$rank[1]
df_winner$Lambda_beta[i] <- lambda[chimp]+beta[rank]
}
df_loser <- data.frame(Chimp=rep(0,n),
Rank=rep(0,n),
Lambda_beta=rep(0,n))
for(i in 1:n){
df_loser$Chimp[i] <- D_sub[[i]]$o[2]
df_loser$Rank[i] <- D_sub[[i]]$rank[2]
chimp <- D_sub[[i]]$o[2]; rank <- D_sub[[i]]$rank[2]
df_loser$Lambda_beta[i] <- lambda[chimp]+beta[rank]
}
df_male <- rbind(df_winner,df_loser)
df_male %>% arrange(desc(Lambda_beta))
setwd("~/Downloads/Results_Thesis/PL/Entire Data/Female/BUC")
load("/Users/finnmaass/Downloads/Results_Thesis/PL/Entire Data/Female/BUC/example-FT-b-dir/example-FT.RData")
#Setup do run and store pictures as pdf
library(dplyr)
index <- first(which(sigmamcmc==0))-1
## Get M
M=SS*index
## Chop down data
lambdamcmc <-lambdamcmc[,,1:index]
betamcmc <- betamcmc[,1:index]
sigmamcmc <- sigmamcmc[1:index]
thetamcmc <- thetamcmc[1:index]
PLOTDIR <- getwd()
save_last_plot_pdf <- function(name,
dir = PLOTDIR,
width_in = 7, height_in = 5) {
pdf_file <- file.path(dir, paste0(name, ".pdf"))
grDevices::dev.copy2pdf(file = pdf_file, width = width_in, height = height_in)
message("Gespeichert: ", pdf_file)
}
## Likelihood function
logpp <- function(dp,lambda,beta,B){
o <- dp$o
n <- length(o)
t <- dp$time
r <- dp$rank
f <- lambda[o,t-B+1] +beta[r]
ff <- numeric(n)
for(j in 1:n){
ff[j]<- f[j]- log(sum(exp(f[j:n])))
}
return(sum(ff))
}
PL_log_lik <- function(D,lambda,beta,B){
logp <- sapply(D,function(x) logpp(dp=x,lambda=lambda,beta=beta,B=B))
return(sum(logp)) #take the sum b.c. we look at the log likelihood!
}
############### the bayes estimates (posterior mean)#################3
n<- dim(lambdamcmc)[1]
tt <- dim(lambdamcmc)[2]
lambdahat <- matrix(0,n,tt)
for(i in 1:n){
lambdahat[i,]<- rowSums(lambdamcmc[i,,])/(M/SS)
}
betahat <- rowSums(betamcmc)/(M/SS)
thetahat <- mean(thetamcmc)
sigmahat <- mean(sigmamcmc)
##########################################################
################## check for convergence
###### log lik
l <- numeric(M/SS)
for(i in 1:(M/SS)){
l[i]<- PL_log_lik(D=D,lambda=lambdamcmc[,,i],beta=betamcmc[,i],B=B)
}
plot(l,type='l',xlab="MCMC-sample",ylab = "log-lkd")
save_last_plot_pdf("m_log-likelihood")
#plot(l[-(1:1000)],type='l',ylab="log-lik")
#######sigma
plot(sigmamcmc,type='l',xlab = "MCMC-sample",ylab = expression(sigma) )
save_last_plot_pdf("m_sigma_traceplot")
#acf(sigmamcmc,lag.max=5000)
#effectiveSize(sigmamcmc)
plot(sigmamcmc,type='l',xlab = "MCMC-sample",ylab = expression(sigma) )
acf(sigmamcmc,lag.max=5000, main="ACF of sigma")
save_last_plot_pdf("m_sigma_acf_traceplot")
############beta
############beta
plot(betamcmc[5,-c(1:1000)],type='l', xlab = "MCMC-sample",ylab = expression(beta),ylim=c(-3,3)) #5 b.c. we just pick a random one?
save_last_plot_pdf("m_beta_traceplot")
#All levels seems to show convergence. But it  doesnt really fit what we have for male
apply(betamcmc,1,lines)
#acf(betamcmc[5,-c(1:1000)],lag.max = 5000)
#effectiveSize(betamcmc[5,])
plot(betamcmc[5,-c(1:1000)],type='l', xlab = "MCMC-sample",ylab = expression(beta),ylim=c(-3,3)) #5 b.c. we just pick a random one?
acf(betamcmc[5,-c(1:1000)],lag.max = 5000,main="ACF of beta")
save_last_plot_pdf("m_beta_acf_traceplot")
###########theta
plot(thetamcmc,type='l',xlab="MCMC-sample",ylab = expression(theta))
save_last_plot_pdf("m_theta_traceplot")
#acf(thetamcmc,lag.max = 5000)
plot(thetamcmc,type='l',xlab="MCMC-sample",ylab = expression(theta))
acf(thetamcmc,lag.max = 5000,main="ACF of theta")
save_last_plot_pdf("m_theta_acf_traceplot")
## lambda
plot(lambdamcmc[10,10,-c(1:1000)],type='l')
save_last_plot_pdf("m_lambda_traceplot")
#acf(lambdamcmc[10,10,-c(1:1000)],lag.max = 8000)
#effectiveSize(lambdamcmc[10,10,])
plot(lambdamcmc[10,10,-c(1:1000)],type='l')
acf(lambdamcmc[10,10,-c(1:1000)],lag.max = 8000,main="ACF of lambda")
save_last_plot_pdf("m_lambda_acf_traceplot")
########## checking the monotonicity of the betas
C <- matrix(0,(M/SS)*nd,2)
for(i in 1:nd){
C[((i-1)*(M/SS)+1):(i*(M/SS)),1]<- betamcmc[i,]
C[((i-1)*(M/SS)+1):(i*(M/SS)),2]<- i
}
boxplot(C[,1]~C[,2],ylab="values",xlab="ranks")
abline(h=0,col='red',lty="dashed")
save_last_plot_pdf("m_beta_boxplot")
###################################################
plot(lambdamcmc[10,10,-c(1:1000)],type='l',ylab = expression(lambda))
acf(lambdamcmc[10,10,-c(1:1000)],lag.max = 8000,main="ACF of lambda")
## lambda
plot(lambdamcmc[10,10,-c(1:1000)],type='l',ylab = expression(lambda))
save_last_plot_pdf("m_lambda_traceplot")
load("/Users/finnmaass/Downloads/Results_Thesis/PL/Entire Data/Male/BUC/example-FT-b-dir/example-FT.RData")
